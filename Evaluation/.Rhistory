q()
Test the Law Of Large Numbers for N random normally distributed numbers with mean = 0, stdev=1:
Create an R script that will count how many of these numbers fall between -1 and 1 and divide
by the total quantity of N
You know that E(X) = 68.2%
Check that Mean(Xn)->E(X) as you rerun your script while increasing N
Hint:
1. Initialize sample size
2. Initialize counter
3. loop for(i in rnorm(size))
4. Check if the iterated variable falls
5. Increase counter if the condition is true
6. return a result <- counter / N
n <-10
c<-0
for (i in rnorm (n,mean = 0,sd = 1)) {
if(i>-1 && i<1){
c<-c+1
}
}
r <- c / n
r
2+5
n <-10
c<-0
for (i in rnorm (n,mean = 0,sd = 1)) {
if(i>-1 && i<1){
c<-c+1
}
}
r <- c / n
r
revenue <- c(14574.49, 7606.46, 8611.41, 9175.41, 8058.65, 8105.44, 11496.28, 9766.09, 10305.32, 14379.96, 10713.97, 15433.50)
expenses <- c(12051.82, 5695.07, 12319.20, 12089.72, 8658.57, 840.20, 3285.73, 5821.12, 6976.93, 16618.61, 10054.37, 3803.96)
#Solution
#Calculate Profit As The Differences Between Revenue And Expenses
profit <- revenue - expenses
profit
#Calculate Profit Remaining After Tax Is Deducted
profit.after.tax <- profit -tax
profit.after.tax
#Calculate Tax As 30% Of Profit And Round To 2 Decimal Points
tax <- round(0.30 * profit, 2)
tax
#Calculate Profit Remaining After Tax Is Deducted
profit.after.tax <- profit -tax
profit.after.tax
#Calculate The Profit Margin As Profit After Tax Over Revenue
#Round To 2 Decimal Points, Then Multiply By 100 To Get %
profit.margin <- round(profit.after.tax / revenue, 2) * 100
profit.margin
#Calculate The Mean Profit After Tax For The 12 Months
mean_pat <- mean(profit.after.tax)
mean_pat
#Continuacion de compaÃ±ero
#Find The Months With Above-Mean Profit After Tax
good.months <- profit.after.tax > mean_pat
good.months
#Bad Months Are The Opposite Of Good Months !
bad.months <- !good.months
bad.months
#The Best Month Is Where Profit After Tax Was Equal To The Maximum
best.month <- profit.after.tax == (profit.after.tax)
best.month
#The Worst Month Is Where Profit After Tax Was Equal To The Minimum
worst.month <-profit.after.tax == min(profit.after.tax)
worst.month
#Convert All Calculations To Units Of One Thousand Dollars
revenue.1000 <- round(revenue / 1000, 0)
expenses.1000 <- round(expenses / 1000, 0)
profit.1000 <- round(profit / 1000, 0)
profit.after.tax.1000 <- round(profit.after.tax / 1000, 0)
#Print Results
revenue.1000
expenses.1000
profit.1000
profit.after.tax.1000
profit.margin
good.months
bad.months
best.month
worst.month
M <- rbind(
revenue.1000,
expenses.1000,
profit.1000,
profit.after.tax.1000,
profit.margin,
good.months,
bad.months,
best.month,
worst.month
)
#Print The Matrix
M
#Dividimos nuestro dataset en datos de entrenamiento y datos de testing para implementarlo en nuestro algoritmo en este caso
#75% de la data en datos de training y 35% en datos de test
install.packages('caTools')
library(caTools)
#Dividimos nuestro dataset en datos de entrenamiento y datos de testing para implementarlo en nuestro algoritmo en este caso
#75% de la data en datos de training y 35% en datos de test
install.packages("tidyverse", lib = "/usr/lib/R/library")
install.packages('caTools')
#Dividimos nuestro dataset en datos de entrenamiento y datos de testing para implementarlo en nuestro algoritmo en este caso
#75% de la data en datos de training y 35% en datos de test
install.packages("caTools", lib = "/usr/lib/R/library")
install.packages('installR')
#Configuramos nuestro working directory
setwd('/home/leonardo/MineriaDeDatos/Data_Mining/Evaluation')
#cargamos nuestro csv y lo asignamos a la variable data
data <- read.csv("Social_Network_Ads.csv")
data
#limitamos la data a utilizar para mejor prediccion
data = data[3:5]
#transformamos nuestro valor
data$Purchased = factor(data$Purchased, levels = c(0, 1))
library(caTools)
set.seed(123)
split = sample.split(data$Purchased, SplitRatio = 0.75)
#Dividimos nuestro dataset en datos de entrenamiento y datos de testing para implementarlo en nuestro algoritmo en este caso
#75% de la data en datos de training y 35% en datos de test
install.packages("ctv")
library(caTools)
install.packages("caTools", lib = "/usr/lib/R/library")
install.packages('installR')
#Configuramos nuestro workspace
setwd('/home/leonardo/MineriaDeDatos/Data_Mining/Evaluation')
#cargamos nuestro csv y lo asignamos a la variable data
data <- read.csv("Social_Network_Ads.csv")
data
#limitamos la data a utilizar para mejor prediccion
data = data[3:5]
#transformamos nuestro valor
data$Purchased = factor(data$Purchased, levels = c(0, 1))
#Dividimos nuestro dataset en datos de entrenamiento y datos de testing para implementarlo en nuestro algoritmo en este caso
library(caTools)
set.seed(123)
split = sample.split(data$Purchased, SplitRatio = 0.75)
training_set = subset(data, split == TRUE)
test_set = subset(data, split == FALSE)
#Normalizamos los datos para poder obtener el mejor rendmiento del algoritmo
training_set[-3] = scale(training_set[-3])
test_set[-3] = scale(test_set[-3])
#cargamos nuestra liberia e1071 para implementar nuestro algoritmo naivebayes
library(e1071)
classifier = naiveBayes(x = training_set[-3],
y = training_set$Purchased)
#Creamos nuestra prediccion
y_pred = predict(classifier, newdata = test_set[-3])
#2nd part
library(ElemStatLearn)
set = training_set
X1 = seq(min(set[, 1]) - 1, max(set[, 1]) + 1, by = 0.01)
X2 = seq(min(set[, 2]) - 1, max(set[, 2]) + 1, by = 0.01)
grid_set = expand.grid(X1, X2)
colnames(grid_set) = c('Age', 'EstimatedSalary')
y_grid = predict(classifier, newdata = grid_set)
plot(set[, -3],
main = ' Naive Bayes  Classifier (Training set)',
xlab = 'Age', ylab = 'Estimated Salary',
xlim = range(X1), ylim = range(X2))
contour(X1, X2, matrix(as.numeric(y_grid), length(X1), length(X2)), add = TRUE)
points(grid_set, pch = '.', col = ifelse(y_grid == 1, 'springgreen3', 'tomato'))
points(set, pch = 21, bg = ifelse(set[, 3] == 1, 'green4', 'red3'))
set = test_set
X1 = seq(min(set[, 1]) - 1, max(set[, 1]) + 1, by = 0.01)
X2 = seq(min(set[, 2]) - 1, max(set[, 2]) + 1, by = 0.01)
grid_set = expand.grid(X1, X2)
colnames(grid_set) = c('Age', 'EstimatedSalary')
y_grid = predict(classifier, newdata = grid_set)
plot(set[, -3], main = 'SVM (Test set)',
xlab = 'Age', ylab = 'Estimated Salary',
xlim = range(X1), ylim = range(X2))
contour(X1, X2, matrix(as.numeric(y_grid), length(X1), length(X2)), add = TRUE)
points(grid_set, pch = '.', col = ifelse(y_grid == 1, 'springgreen3', 'tomato'))
points(set, pch = 21, bg = ifelse(set[, 3] == 1, 'green4', 'red3'))
View(data)
View(classifier)
View(grid_set)
View(set)
